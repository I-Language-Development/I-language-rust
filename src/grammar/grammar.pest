// I Language pest grammar.
// Version: 0.2.0

// Copyright (c) 2023-present I Language Development.

// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the 'Software'),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

// TODO (ElBe): Types according to https://pest.rs/book/examples/json.html

//////////
// FILE //
//////////

/// Entire file matching rule
file = _{ SOI ~ ((( assignment | import | _use ) ~ ";" ~ ( NEWLINE+ | comment )) | comment )* ~ EOI }


////////////
// IMPORT //
////////////

/// Import statement: "import xyz from xyz as xyz"
import = ${ "import" ~ wsc ~ identifier ~ ( wsc ~ import_from )? ~ ( wsc ~ import_as )? }

/// Import from statement: "... from xyz"
import_from = ${ "from" ~ wsc ~ identifier }

/// Import as statement: "... as xyz"
import_as = ${ "as" ~ wsc ~ identifier }


/////////
// USE //
/////////

/// Use feature statement (compiler flags): "use FEATURE"
_use = ${ "use" ~ wsc ~ use_feature }

/// Use features
use_feature = _{ system | shell | garbage_collection | settings | rust | speedups }

system = { ^"System" }
shell = { ^"Shell" }
settings = { ^"Settings" }
garbage_collection = { ^"GarbageCollection" | ^"GC" }
rust = { ^"Rust" }
speedups = { ^"Speedups" }


//////////////////
// ASSIGNEMENTS //
//////////////////

/// Variable assignment structure
// TODO (ElBe): Assignment without value
assignment = ${ ( ( _const ~ wsc ~ _type ) | (( var ~ wsc )? ~ _type | var ) ) ~ wsc ~ identifier ~ wsc? ~ "=" ~ wsc? ~ ( identifier | type_definition ) }
_const = { "const" }
var = { "var" }


//////////////////////
// TYPE DEFINITIONS //
//////////////////////

/// Type definition
type_definition = _{ list | string | float | integer_with_sign }

// List definition: [ TYPE_DEF,* ]
list = { "[" ~ ( ( type_definition ~ "," )+ | type_definition ~ ","? )? ~ "]" }

/// String definition: 'text' / "text" / '''text\n''' / """text\n"""
/// In this case \n is not the unicode character, but an actual newline
string = ${ ( "'" ~ string_content_single_quote ~ "'" ) | ( "\"" ~ string_content_double_quote ~ "\"" ) | ( "'''" ~ multiline_string_content_single_quote ~ "'''" ) | ( "\"\"\"" ~ multiline_string_content_double_quote ~ "\"\"\"" ) }

string_content_single_quote = { ( !"'" ~ !NEWLINE ~ ANY )* }
string_content_double_quote = { ( !"\"" ~ !NEWLINE ~ ANY )* }

multiline_string_content_single_quote = { ( !"'''" ~ ANY )* }
multiline_string_content_double_quote = { ( !"\"\"\""  ~ ANY )* }

/// Float definition: 1.23
float = ${ integer_with_sign ~ "." ~ integer }

/// Integer definition (with sign): -123
integer_with_sign = ${ integer_sign ~ integer }
integer_sign = ${ ("+" | "-")? }
integer = ${ ( ASCII_DIGIT ~ "_"? )+ }


////////////////
// IDENTIFIER //
////////////////

/// Identifier: abc_def
identifier = ${ !keywords ~ !_type ~ ( ASCII_ALPHA ~ ( ASCII_ALPHA | "_" )* | ( "_" )* ~ ASCII_ALPHA ~ ( ASCII_ALPHA | "_" )* ) }


////////////////
// EXPRESSION //
////////////////

// expression = { term ~ ( plus | minus | multiply | divide | power ) ~ term }
// term = { ( type_definition | identifier | expression | term ) | "(" ~ ( type_definition | identifier | expression | term ) ~ ")" }
// For recursive rules, a pratt parser is required: https://docs.rs/pest/latest/pest/pratt_parser/index.html
// TODO (ElBe): Add pratt parser

plus = { "+" }
minus = { "-" }
multiply = { "*" }
divide = { "/" }
power = { "^" }


////////////////////
// RESERVED NAMES //
////////////////////

/// Reserved keywords
keywords = { "as" | "break" | "case" | "catch" | "class" | "const" | "continue" | "default" | "delete" | "else" | "elseif" | "finally" | "for" | "from" | "func" | "function" | "if" | "import" | "in" | "match" | "not" | "raise" | "return" | "try" | "type" | "use" | "var" | "while" }


/// Reserved types
_type = { "array" | "bool" | "char" | "dict" | "dictionary" | "float" | "int" | "integer" | "list" | "str" | "string" | "tuple" }


///////////////////////////
// WHITESPACE OR COMMENT //
///////////////////////////

/// wsc = *w*hite*s*pace or *c*omment
wsc = @{ WHITESPACE+ | WHITESPACE+ ~ COMMENT* ~ WHITESPACE+ }


/////////////
// COMMENT //
/////////////

COMMENT = { multiline_comment }

comment = _{ "//" ~ (!NEWLINE ~ ANY)* ~ NEWLINE+ }
multiline_comment = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }


////////////////
// WHITESPACE //
////////////////

WHITESPACE = _{ " " | "\t" }
